/**
 * Generated by "@vuepress/internal-site-data"
 */
export const siteData = {
  "title": "yjkblog",
  "description": "YANG JK BLOG",
  "base": "/",
  "headTags": [
    [
      "link",
      {
        "rel": "icon",
        "href": "/favicon.ico"
      }
    ],
    [
      "meta",
      {
        "name": "viewport",
        "content": "width=device-width,initial-scale=1,user-scalable=no"
      }
    ]
  ],
  "pages": [
    {
      "title": "Home",
      "frontmatter": {
        "home": true,
        "heroText": "vuepress-theme-reco",
        "heroTextStyle": {
          "color:#fff !important": null
        },
        "tagline": "昨日の経験は明日力になる",
        "bgImage": "/bg.jpg",
        "bgImageStyle": {
          "height": "800px"
        },
        "isShowTitleInHome": false,
        "actionText": "Guide",
        "actionLink": "/views/other/guide",
        "features": [
          {
            "title": "Yesterday",
            "details": "开发一款看着开心、写着顺手的 vuepress 博客主题"
          },
          {
            "title": "Today",
            "details": "希望帮助更多的人花更多的时间在内容创作上，而不是博客搭建上"
          },
          {
            "title": "Tomorrow",
            "details": "希望更多的爱好者能够参与进来，帮助这个主题更好的成长"
          }
        ]
      },
      "regularPath": "/",
      "relativePath": "README.md",
      "key": "v-59bb6e94",
      "path": "/"
    },
    {
      "title": "first page in category2",
      "frontmatter": {
        "title": "first page in category2",
        "date": "2016-12-15T00:00:00.000Z",
        "tags": [
          "tag3"
        ],
        "categories": [
          "category2"
        ]
      },
      "regularPath": "/blogs/category2/2016/121501.html",
      "relativePath": "blogs/category2/2016/121501.md",
      "key": "v-4ddec33a",
      "path": "/blogs/category2/2016/121501.html"
    },
    {
      "title": "vuepress-theme-reco",
      "frontmatter": {
        "title": "vuepress-theme-reco",
        "date": "2019-04-09T00:00:00.000Z"
      },
      "regularPath": "/blogs/other/guide.html",
      "relativePath": "blogs/other/guide.md",
      "key": "v-2b49becd",
      "path": "/blogs/other/guide.html",
      "headers": [
        {
          "level": 2,
          "title": "Use",
          "slug": "use"
        },
        {
          "level": 2,
          "title": "Play Together",
          "slug": "play-together"
        },
        {
          "level": 3,
          "title": "0.x",
          "slug": "_0-x"
        },
        {
          "level": 3,
          "title": "1.x",
          "slug": "_1-x"
        },
        {
          "level": 3,
          "title": "CLI",
          "slug": "cli"
        },
        {
          "level": 2,
          "title": "License",
          "slug": "license"
        }
      ]
    },
    {
      "title": "second page in category1",
      "frontmatter": {
        "title": "second page in category1",
        "date": "2019-09-21T00:00:00.000Z",
        "tags": [
          "tag2"
        ],
        "categories": [
          "category1"
        ]
      },
      "regularPath": "/blogs/category1/2019/092101.html",
      "relativePath": "blogs/category1/2019/092101.md",
      "key": "v-9ff679cc",
      "path": "/blogs/category1/2019/092101.html"
    },
    {
      "title": "first page in category1",
      "frontmatter": {
        "title": "first page in category1",
        "date": "2018-12-15T00:00:00.000Z",
        "tags": [
          "tag1"
        ],
        "categories": [
          "category1"
        ]
      },
      "regularPath": "/blogs/category1/2018/121501.html",
      "relativePath": "blogs/category1/2018/121501.md",
      "key": "v-26bbb24c",
      "path": "/blogs/category1/2018/121501.html"
    },
    {
      "title": "second page in category2",
      "frontmatter": {
        "title": "second page in category2",
        "date": "2017-09-21T00:00:00.000Z",
        "tags": [
          "tag4"
        ],
        "categories": [
          "category2"
        ]
      },
      "regularPath": "/blogs/category2/2017/092101.html",
      "relativePath": "blogs/category2/2017/092101.md",
      "key": "v-11415f7a",
      "path": "/blogs/category2/2017/092101.html"
    },
    {
      "title": "ESLint 配置",
      "frontmatter": {
        "title": "ESLint 配置",
        "date": "2022-04-18T15:45:35.000Z",
        "permalink": "/pages/f344d070a1031ef7",
        "sidebar": "auto",
        "author": "Yang J.K",
        "categories": [
          "前端标准化"
        ],
        "tags": [
          "ESLint"
        ]
      },
      "regularPath": "/blogs/%E5%89%8D%E7%AB%AF%E6%A0%87%E5%87%86%E5%8C%96/ESLint.html",
      "relativePath": "blogs/前端标准化/ESLint.md",
      "key": "v-0fc76610",
      "path": "/pages/f344d070a1031ef7/",
      "headers": [
        {
          "level": 2,
          "title": "ECMAScript 和 JavaScript 的关系",
          "slug": "ecmascript-和-javascript-的关系"
        },
        {
          "level": 2,
          "title": "ES6 与 ECMAScript 2015 的关系",
          "slug": "es6-与-ecmascript-2015-的关系"
        },
        {
          "level": 2,
          "title": "语法提案的批准流程",
          "slug": "语法提案的批准流程"
        },
        {
          "level": 2,
          "title": "ECMAScript 的历史",
          "slug": "ecmascript-的历史"
        },
        {
          "level": 2,
          "title": "部署进度",
          "slug": "部署进度"
        },
        {
          "level": 2,
          "title": "Babel 转码器",
          "slug": "babel-转码器"
        },
        {
          "level": 3,
          "title": "配置文件.babelrc",
          "slug": "配置文件-babelrc"
        },
        {
          "level": 3,
          "title": "命令行转码",
          "slug": "命令行转码"
        },
        {
          "level": 3,
          "title": "babel-node",
          "slug": "babel-node"
        },
        {
          "level": 3,
          "title": "@babel/register 模块",
          "slug": "babel-register-模块"
        },
        {
          "level": 3,
          "title": "babel API",
          "slug": "babel-api"
        },
        {
          "level": 3,
          "title": "@babel/polyfill",
          "slug": "babel-polyfill"
        },
        {
          "level": 3,
          "title": "浏览器环境",
          "slug": "浏览器环境"
        },
        {
          "level": 2,
          "title": "Traceur 转码器",
          "slug": "traceur-转码器"
        },
        {
          "level": 3,
          "title": "直接插入网页",
          "slug": "直接插入网页"
        },
        {
          "level": 3,
          "title": "在线转换",
          "slug": "在线转换"
        },
        {
          "level": 3,
          "title": "命令行转换",
          "slug": "命令行转换"
        },
        {
          "level": 3,
          "title": "Node 环境的用法",
          "slug": "node-环境的用法"
        }
      ],
      "excerpt": "<blockquote>\n<p>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener noreferrer\">http://es6.ruanyifeng.com/<OutboundLink/></a>，教程版权归原作者所有。</p>\n</blockquote>\n<h1 id=\"ecmascript-9-简介\"><a class=\"header-anchor\" href=\"#ecmascript-9-简介\">#</a> ECMAScript 9 简介</h1>\n<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\n"
    },
    {
      "title": "let 和 const 命令",
      "frontmatter": {
        "title": "let 和 const 命令",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/c1edd70a6b7c7872",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/02.let%20%E5%92%8C%20const%20%E5%91%BD%E4%BB%A4.html",
      "relativePath": "blogs/《ES6 教程》笔记/02.let 和 const 命令.md",
      "key": "v-7a8e90ce",
      "path": "/pages/c1edd70a6b7c7872/",
      "headers": [
        {
          "level": 2,
          "title": "let 命令",
          "slug": "let-命令"
        },
        {
          "level": 3,
          "title": "基本用法",
          "slug": "基本用法"
        },
        {
          "level": 3,
          "title": "不存在变量提升",
          "slug": "不存在变量提升"
        },
        {
          "level": 3,
          "title": "暂时性死区",
          "slug": "暂时性死区"
        },
        {
          "level": 3,
          "title": "不允许重复声明",
          "slug": "不允许重复声明"
        },
        {
          "level": 2,
          "title": "块级作用域",
          "slug": "块级作用域"
        },
        {
          "level": 3,
          "title": "为什么需要块级作用域？",
          "slug": "为什么需要块级作用域"
        },
        {
          "level": 3,
          "title": "ES6 的块级作用域",
          "slug": "es6-的块级作用域"
        },
        {
          "level": 3,
          "title": "块级作用域与函数声明",
          "slug": "块级作用域与函数声明"
        },
        {
          "level": 2,
          "title": "const 命令",
          "slug": "const-命令"
        },
        {
          "level": 3,
          "title": "基本用法",
          "slug": "基本用法-2"
        },
        {
          "level": 3,
          "title": "本质",
          "slug": "本质"
        },
        {
          "level": 3,
          "title": "ES6 声明变量的六种方法",
          "slug": "es6-声明变量的六种方法"
        },
        {
          "level": 2,
          "title": "顶层对象的属性",
          "slug": "顶层对象的属性"
        },
        {
          "level": 2,
          "title": "globalThis 对象",
          "slug": "globalthis-对象"
        }
      ],
      "excerpt": "<h1 id=\"let-和-const-命令\"><a class=\"header-anchor\" href=\"#let-和-const-命令\">#</a> let 和 const 命令</h1>\n<h2 id=\"let-命令\"><a class=\"header-anchor\" href=\"#let-命令\">#</a> let 命令</h2>\n<h3 id=\"基本用法\"><a class=\"header-anchor\" href=\"#基本用法\">#</a> 基本用法</h3>\n<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，<strong>只在<code>let</code>命令所在的代码块内有效(块级作用域)</strong>。</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\na<span class=\"token punctuation\">;</span> <span class=\"token comment\">// ReferenceError: a is not defined.</span>\nb<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br></div><!--beforeend--></div><!--afterend-->"
    },
    {
      "title": "变量的解构赋值",
      "frontmatter": {
        "title": "变量的解构赋值",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/b1ab10a62f7564da",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/03.%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html",
      "relativePath": "blogs/《ES6 教程》笔记/03.变量的解构赋值.md",
      "key": "v-2b6b1e91",
      "path": "/pages/b1ab10a62f7564da/",
      "headers": [
        {
          "level": 2,
          "title": "数组的解构赋值",
          "slug": "数组的解构赋值"
        },
        {
          "level": 3,
          "title": "基本用法",
          "slug": "基本用法"
        },
        {
          "level": 3,
          "title": "默认值",
          "slug": "默认值"
        },
        {
          "level": 2,
          "title": "对象的解构赋值",
          "slug": "对象的解构赋值"
        },
        {
          "level": 3,
          "title": "简介",
          "slug": "简介"
        },
        {
          "level": 3,
          "title": "默认值",
          "slug": "默认值-2"
        },
        {
          "level": 3,
          "title": "注意点",
          "slug": "注意点"
        },
        {
          "level": 2,
          "title": "字符串的解构赋值",
          "slug": "字符串的解构赋值"
        },
        {
          "level": 2,
          "title": "数值和布尔值的解构赋值",
          "slug": "数值和布尔值的解构赋值"
        },
        {
          "level": 2,
          "title": "函数参数的解构赋值",
          "slug": "函数参数的解构赋值"
        },
        {
          "level": 2,
          "title": "圆括号问题",
          "slug": "圆括号问题"
        },
        {
          "level": 3,
          "title": "不能使用圆括号的情况",
          "slug": "不能使用圆括号的情况"
        },
        {
          "level": 3,
          "title": "可以使用圆括号的情况",
          "slug": "可以使用圆括号的情况"
        },
        {
          "level": 2,
          "title": "用途",
          "slug": "用途"
        }
      ],
      "excerpt": "<h1 id=\"变量的解构赋值\"><a class=\"header-anchor\" href=\"#变量的解构赋值\">#</a> 变量的解构赋值</h1>\n<h2 id=\"数组的解构赋值\"><a class=\"header-anchor\" href=\"#数组的解构赋值\">#</a> 数组的解构赋值</h2>\n<h3 id=\"基本用法\"><a class=\"header-anchor\" href=\"#基本用法\">#</a> 基本用法</h3>\n<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值，这被称为解构</strong>（Destructuring）。</p>\n<p>以前，为变量赋值，只能直接指定值。</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br></div><!--beforeend--></div><!--afterend-->"
    },
    {
      "title": "字符串的扩展",
      "frontmatter": {
        "title": "字符串的扩展",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/ca89eca8adeba5f4",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/04.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95.html",
      "relativePath": "blogs/《ES6 教程》笔记/04.字符串的扩展.md",
      "key": "v-14de622d",
      "path": "/pages/ca89eca8adeba5f4/",
      "headers": [
        {
          "level": 2,
          "title": "字符的 Unicode 表示法",
          "slug": "字符的-unicode-表示法"
        },
        {
          "level": 2,
          "title": "字符串的遍历器接口",
          "slug": "字符串的遍历器接口"
        },
        {
          "level": 2,
          "title": "直接输入 U+2028 和 U+2029",
          "slug": "直接输入-u-2028-和-u-2029"
        },
        {
          "level": 2,
          "title": "JSON.stringify() 的改造",
          "slug": "json-stringify-的改造"
        },
        {
          "level": 2,
          "title": "模板字符串",
          "slug": "模板字符串"
        },
        {
          "level": 2,
          "title": "实例：模板编译",
          "slug": "实例-模板编译"
        },
        {
          "level": 2,
          "title": "标签模板",
          "slug": "标签模板"
        },
        {
          "level": 2,
          "title": "模板字符串的限制",
          "slug": "模板字符串的限制"
        }
      ],
      "excerpt": "<h1 id=\"字符串的扩展\"><a class=\"header-anchor\" href=\"#字符串的扩展\">#</a> 字符串的扩展</h1>\n<p>本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。</p>\n<h2 id=\"字符的-unicode-表示法\"><a class=\"header-anchor\" href=\"#字符的-unicode-表示法\">#</a> 字符的 Unicode 表示法</h2>\n<p>ES6 加强了对 Unicode 的支持，允许采用<code>\\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token string\">\"\\u0061\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// \"a\"</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend-->"
    },
    {
      "title": "字符串的新增方法",
      "frontmatter": {
        "title": "字符串的新增方法",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/a650b4a0ebfc9350",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/05.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.html",
      "relativePath": "blogs/《ES6 教程》笔记/05.字符串的新增方法.md",
      "key": "v-c085bf28",
      "path": "/pages/a650b4a0ebfc9350/",
      "headers": [
        {
          "level": 2,
          "title": "String.fromCodePoint()",
          "slug": "string-fromcodepoint"
        },
        {
          "level": 2,
          "title": "String.raw()",
          "slug": "string-raw"
        },
        {
          "level": 2,
          "title": "实例方法：codePointAt()",
          "slug": "实例方法-codepointat"
        },
        {
          "level": 2,
          "title": "实例方法：normalize()",
          "slug": "实例方法-normalize"
        },
        {
          "level": 2,
          "title": "实例方法：includes() 包含, startsWith() 头部包含, endsWith() 末尾包含",
          "slug": "实例方法-includes-包含-startswith-头部包含-endswith-末尾包含"
        },
        {
          "level": 2,
          "title": "实例方法：repeat() 重复",
          "slug": "实例方法-repeat-重复"
        },
        {
          "level": 2,
          "title": "实例方法：padStart() 补全头部，padEnd() 补全末尾",
          "slug": "实例方法-padstart-补全头部-padend-补全末尾"
        },
        {
          "level": 2,
          "title": "实例方法：trimStart() 修剪头部，trimEnd() 修剪末尾",
          "slug": "实例方法-trimstart-修剪头部-trimend-修剪末尾"
        },
        {
          "level": 2,
          "title": "实例方法：matchAll()",
          "slug": "实例方法-matchall"
        }
      ],
      "excerpt": "<h1 id=\"字符串的新增方法\"><a class=\"header-anchor\" href=\"#字符串的新增方法\">#</a> 字符串的新增方法</h1>\n<p>本章介绍字符串对象的新增方法。</p>\n<h2 id=\"string-fromcodepoint\"><a class=\"header-anchor\" href=\"#string-fromcodepoint\">#</a> String.fromCodePoint()</h2>\n<p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code>String<span class=\"token punctuation\">.</span><span class=\"token function\">fromCharCode</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x20bb7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// \"ஷ\"</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend-->"
    },
    {
      "title": "正则的扩展",
      "frontmatter": {
        "title": "正则的扩展",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/0473261a6ab0ee8c",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/06.%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95.html",
      "relativePath": "blogs/《ES6 教程》笔记/06.正则的扩展.md",
      "key": "v-9a69caf4",
      "path": "/pages/0473261a6ab0ee8c/",
      "headers": [
        {
          "level": 2,
          "title": "RegExp 构造函数",
          "slug": "regexp-构造函数"
        },
        {
          "level": 2,
          "title": "字符串的正则方法",
          "slug": "字符串的正则方法"
        },
        {
          "level": 2,
          "title": "u 修饰符",
          "slug": "u-修饰符"
        },
        {
          "level": 2,
          "title": "RegExp.prototype.unicode 属性",
          "slug": "regexp-prototype-unicode-属性"
        },
        {
          "level": 2,
          "title": "y 修饰符",
          "slug": "y-修饰符"
        },
        {
          "level": 2,
          "title": "RegExp.prototype.sticky 属性",
          "slug": "regexp-prototype-sticky-属性"
        },
        {
          "level": 2,
          "title": "RegExp.prototype.flags 属性",
          "slug": "regexp-prototype-flags-属性"
        },
        {
          "level": 2,
          "title": "s 修饰符：dotAll 模式",
          "slug": "s-修饰符-dotall-模式"
        },
        {
          "level": 2,
          "title": "后行断言",
          "slug": "后行断言"
        },
        {
          "level": 2,
          "title": "Unicode 属性类",
          "slug": "unicode-属性类"
        },
        {
          "level": 2,
          "title": "具名组匹配",
          "slug": "具名组匹配"
        },
        {
          "level": 3,
          "title": "简介",
          "slug": "简介"
        },
        {
          "level": 3,
          "title": "解构赋值和替换",
          "slug": "解构赋值和替换"
        },
        {
          "level": 3,
          "title": "引用",
          "slug": "引用"
        },
        {
          "level": 2,
          "title": "String.prototype.matchAll()",
          "slug": "string-prototype-matchall"
        }
      ],
      "excerpt": "<h1 id=\"正则的扩展\"><a class=\"header-anchor\" href=\"#正则的扩展\">#</a> 正则的扩展</h1>\n<h2 id=\"regexp-构造函数\"><a class=\"header-anchor\" href=\"#regexp-构造函数\">#</a> RegExp 构造函数</h2>\n<p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>\n<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">var</span> regex <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"xyz\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"i\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 等价于</span>\n<span class=\"token keyword\">var</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">xyz</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">i</span></span><span class=\"token punctuation\">;</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br></div><!--beforeend--></div><!--afterend-->"
    },
    {
      "title": "函数的扩展",
      "frontmatter": {
        "title": "函数的扩展",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/8ed309d668b20264",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/08.%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html",
      "relativePath": "blogs/《ES6 教程》笔记/08.函数的扩展.md",
      "key": "v-fc1b12ae",
      "path": "/pages/8ed309d668b20264/",
      "headers": [
        {
          "level": 2,
          "title": "函数参数的默认值",
          "slug": "函数参数的默认值"
        },
        {
          "level": 3,
          "title": "基本用法",
          "slug": "基本用法"
        },
        {
          "level": 3,
          "title": "与解构赋值默认值结合使用",
          "slug": "与解构赋值默认值结合使用"
        },
        {
          "level": 3,
          "title": "参数默认值的位置",
          "slug": "参数默认值的位置"
        },
        {
          "level": 3,
          "title": "函数的 length 属性",
          "slug": "函数的-length-属性"
        },
        {
          "level": 3,
          "title": "作用域",
          "slug": "作用域"
        },
        {
          "level": 3,
          "title": "应用",
          "slug": "应用"
        },
        {
          "level": 2,
          "title": "rest 参数",
          "slug": "rest-参数"
        },
        {
          "level": 2,
          "title": "严格模式",
          "slug": "严格模式"
        },
        {
          "level": 2,
          "title": "name 属性",
          "slug": "name-属性"
        },
        {
          "level": 2,
          "title": "箭头函数",
          "slug": "箭头函数"
        },
        {
          "level": 3,
          "title": "基本用法",
          "slug": "基本用法-2"
        },
        {
          "level": 3,
          "title": "使用注意点",
          "slug": "使用注意点"
        },
        {
          "level": 3,
          "title": "不适用场合",
          "slug": "不适用场合"
        },
        {
          "level": 3,
          "title": "嵌套的箭头函数",
          "slug": "嵌套的箭头函数"
        },
        {
          "level": 2,
          "title": "尾调用优化",
          "slug": "尾调用优化"
        },
        {
          "level": 3,
          "title": "什么是尾调用？",
          "slug": "什么是尾调用"
        },
        {
          "level": 3,
          "title": "尾调用优化",
          "slug": "尾调用优化-2"
        },
        {
          "level": 3,
          "title": "尾递归",
          "slug": "尾递归"
        },
        {
          "level": 3,
          "title": "递归函数的改写",
          "slug": "递归函数的改写"
        },
        {
          "level": 3,
          "title": "严格模式",
          "slug": "严格模式-2"
        },
        {
          "level": 3,
          "title": "尾递归优化的实现",
          "slug": "尾递归优化的实现"
        },
        {
          "level": 2,
          "title": "函数参数的尾逗号",
          "slug": "函数参数的尾逗号"
        },
        {
          "level": 2,
          "title": "Function.prototype.toString()",
          "slug": "function-prototype-tostring"
        },
        {
          "level": 2,
          "title": "catch 命令的参数省略",
          "slug": "catch-命令的参数省略"
        }
      ],
      "excerpt": "<h1 id=\"函数的扩展\"><a class=\"header-anchor\" href=\"#函数的扩展\">#</a> 函数的扩展</h1>\n<h2 id=\"函数参数的默认值\"><a class=\"header-anchor\" href=\"#函数参数的默认值\">#</a> 函数参数的默认值</h2>\n<h3 id=\"基本用法\"><a class=\"header-anchor\" href=\"#基本用法\">#</a> 基本用法</h3>\n<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  y <span class=\"token operator\">=</span> y <span class=\"token operator\">||</span> <span class=\"token string\">\"World\"</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Hello World</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"China\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Hello China</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Hello World</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br></div><!--beforeend--></div><!--afterend-->"
    },
    {
      "title": "数值的扩展",
      "frontmatter": {
        "title": "数值的扩展",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/5dfea9a0f2d1a392",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/07.%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95.html",
      "relativePath": "blogs/《ES6 教程》笔记/07.数值的扩展.md",
      "key": "v-7a34a994",
      "path": "/pages/5dfea9a0f2d1a392/",
      "headers": [
        {
          "level": 2,
          "title": "二进制和八进制表示法",
          "slug": "二进制和八进制表示法"
        },
        {
          "level": 2,
          "title": "Number.isFinite() 是否为有限, Number.isNaN() 是否为 NaN",
          "slug": "number-isfinite-是否为有限-number-isnan-是否为-nan"
        },
        {
          "level": 2,
          "title": "Number.parseInt(), Number.parseFloat()",
          "slug": "number-parseint-number-parsefloat"
        },
        {
          "level": 2,
          "title": "Number.isInteger() 是否为整数",
          "slug": "number-isinteger-是否为整数"
        },
        {
          "level": 2,
          "title": "Number.EPSILON 用于浮点数误差检查",
          "slug": "number-epsilon-用于浮点数误差检查"
        },
        {
          "level": 2,
          "title": "安全整数和 Number.isSafeInteger()",
          "slug": "安全整数和-number-issafeinteger"
        },
        {
          "level": 2,
          "title": "Math 对象的扩展",
          "slug": "math-对象的扩展"
        },
        {
          "level": 3,
          "title": "Math.trunc() 去除一个数的小数部分，返回整数部分",
          "slug": "math-trunc-去除一个数的小数部分-返回整数部分"
        },
        {
          "level": 3,
          "title": "Math.sign() 判断一个数是正数、负数、还是零",
          "slug": "math-sign-判断一个数是正数、负数、还是零"
        },
        {
          "level": 3,
          "title": "Math.cbrt() 计算一个数的立方根",
          "slug": "math-cbrt-计算一个数的立方根"
        },
        {
          "level": 3,
          "title": "Math.clz32()",
          "slug": "math-clz32"
        },
        {
          "level": 3,
          "title": "Math.imul()",
          "slug": "math-imul"
        },
        {
          "level": 3,
          "title": "Math.fround()",
          "slug": "math-fround"
        },
        {
          "level": 3,
          "title": "Math.hypot()",
          "slug": "math-hypot"
        },
        {
          "level": 3,
          "title": "对数方法",
          "slug": "对数方法"
        },
        {
          "level": 3,
          "title": "双曲函数方法",
          "slug": "双曲函数方法"
        },
        {
          "level": 2,
          "title": "指数运算符",
          "slug": "指数运算符"
        },
        {
          "level": 2,
          "title": "BigInt 数据类型",
          "slug": "bigint-数据类型"
        },
        {
          "level": 3,
          "title": "简介",
          "slug": "简介"
        },
        {
          "level": 3,
          "title": "BigInt 对象",
          "slug": "bigint-对象"
        },
        {
          "level": 3,
          "title": "转换规则",
          "slug": "转换规则"
        },
        {
          "level": 3,
          "title": "数学运算",
          "slug": "数学运算"
        },
        {
          "level": 3,
          "title": "其他运算",
          "slug": "其他运算"
        }
      ],
      "excerpt": "<h1 id=\"数值的扩展\"><a class=\"header-anchor\" href=\"#数值的扩展\">#</a> 数值的扩展</h1>\n<h2 id=\"二进制和八进制表示法\"><a class=\"header-anchor\" href=\"#二进制和八进制表示法\">#</a> 二进制和八进制表示法</h2>\n<p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token number\">0b111110111</span> <span class=\"token operator\">===</span> <span class=\"token number\">503</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token number\">0o767</span> <span class=\"token operator\">===</span> <span class=\"token number\">503</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br></div><!--beforeend--></div><!--afterend-->"
    },
    {
      "title": "对象的扩展",
      "frontmatter": {
        "title": "对象的扩展",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/b5e3e0a0ff6e9c25",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/10.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html",
      "relativePath": "blogs/《ES6 教程》笔记/10.对象的扩展.md",
      "key": "v-5ff2d8b6",
      "path": "/pages/b5e3e0a0ff6e9c25/",
      "headers": [
        {
          "level": 2,
          "title": "属性的简洁表示法",
          "slug": "属性的简洁表示法"
        },
        {
          "level": 2,
          "title": "属性名表达式",
          "slug": "属性名表达式"
        },
        {
          "level": 2,
          "title": "方法的 name 属性",
          "slug": "方法的-name-属性"
        },
        {
          "level": 2,
          "title": "属性的可枚举性和遍历",
          "slug": "属性的可枚举性和遍历"
        },
        {
          "level": 3,
          "title": "可枚举性",
          "slug": "可枚举性"
        },
        {
          "level": 3,
          "title": "属性的遍历",
          "slug": "属性的遍历"
        },
        {
          "level": 2,
          "title": "super 关键字",
          "slug": "super-关键字"
        },
        {
          "level": 2,
          "title": "对象的扩展运算符",
          "slug": "对象的扩展运算符"
        },
        {
          "level": 3,
          "title": "解构赋值",
          "slug": "解构赋值"
        },
        {
          "level": 3,
          "title": "扩展运算符",
          "slug": "扩展运算符"
        },
        {
          "level": 2,
          "title": "链判断运算符",
          "slug": "链判断运算符"
        },
        {
          "level": 2,
          "title": "Null 判断运算符",
          "slug": "null-判断运算符"
        }
      ],
      "excerpt": "<h1 id=\"对象的扩展\"><a class=\"header-anchor\" href=\"#对象的扩展\">#</a> 对象的扩展</h1>\n<p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍<code>Object</code>对象的新增方法。</p>\n"
    },
    {
      "title": "数组的扩展",
      "frontmatter": {
        "title": "数组的扩展",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/e34009d60d8bc4b2",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/09.%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95.html",
      "relativePath": "blogs/《ES6 教程》笔记/09.数组的扩展.md",
      "key": "v-5d8cba3a",
      "path": "/pages/e34009d60d8bc4b2/",
      "headers": [
        {
          "level": 2,
          "title": "扩展运算符",
          "slug": "扩展运算符"
        },
        {
          "level": 3,
          "title": "含义",
          "slug": "含义"
        },
        {
          "level": 3,
          "title": "替代函数的 apply 方法",
          "slug": "替代函数的-apply-方法"
        },
        {
          "level": 3,
          "title": "扩展运算符的应用",
          "slug": "扩展运算符的应用"
        },
        {
          "level": 2,
          "title": "Array.from()",
          "slug": "array-from"
        },
        {
          "level": 2,
          "title": "Array.of() 总是返回参数值组成的数组",
          "slug": "array-of-总是返回参数值组成的数组"
        },
        {
          "level": 2,
          "title": "数组实例的 copyWithin()",
          "slug": "数组实例的-copywithin"
        },
        {
          "level": 2,
          "title": "数组实例的 find() 和 findIndex()",
          "slug": "数组实例的-find-和-findindex"
        },
        {
          "level": 2,
          "title": "数组实例的 fill()",
          "slug": "数组实例的-fill"
        },
        {
          "level": 2,
          "title": "数组实例的 entries()，keys() 和 values()",
          "slug": "数组实例的-entries-keys-和-values"
        },
        {
          "level": 2,
          "title": "数组实例的 includes()",
          "slug": "数组实例的-includes"
        },
        {
          "level": 2,
          "title": "数组实例的 flat()，flatMap()",
          "slug": "数组实例的-flat-flatmap"
        },
        {
          "level": 2,
          "title": "数组的空位",
          "slug": "数组的空位"
        },
        {
          "level": 2,
          "title": "Array.prototype.sort() 的排序稳定性",
          "slug": "array-prototype-sort-的排序稳定性"
        }
      ],
      "excerpt": "<h1 id=\"数组的扩展\"><a class=\"header-anchor\" href=\"#数组的扩展\">#</a> 数组的扩展</h1>\n<h2 id=\"扩展运算符\"><a class=\"header-anchor\" href=\"#扩展运算符\">#</a> 扩展运算符</h2>\n<h3 id=\"含义\"><a class=\"header-anchor\" href=\"#含义\">#</a> 含义</h3>\n<p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 1 2 3</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 1 2 3 4 5</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelectorAll</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// [&lt;div>, &lt;div>, &lt;div>]</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br></div><!--beforeend--></div><!--afterend-->"
    },
    {
      "title": "对象的新增方法",
      "frontmatter": {
        "title": "对象的新增方法",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/e85e68947502cf90",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/11.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.html",
      "relativePath": "blogs/《ES6 教程》笔记/11.对象的新增方法.md",
      "key": "v-2534c2cf",
      "path": "/pages/e85e68947502cf90/",
      "headers": [
        {
          "level": 2,
          "title": "Object.is()",
          "slug": "object-is"
        },
        {
          "level": 2,
          "title": "Object.assign()",
          "slug": "object-assign"
        },
        {
          "level": 3,
          "title": "基本用法",
          "slug": "基本用法"
        },
        {
          "level": 3,
          "title": "注意点",
          "slug": "注意点"
        },
        {
          "level": 3,
          "title": "常见用途",
          "slug": "常见用途"
        },
        {
          "level": 2,
          "title": "Object.getOwnPropertyDescriptors()",
          "slug": "object-getownpropertydescriptors"
        },
        {
          "level": 2,
          "title": "__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()",
          "slug": "proto-属性-object-setprototypeof-object-getprototypeof"
        },
        {
          "level": 3,
          "title": "__proto__属性",
          "slug": "proto-属性"
        },
        {
          "level": 3,
          "title": "Object.setPrototypeOf()",
          "slug": "object-setprototypeof"
        },
        {
          "level": 3,
          "title": "Object.getPrototypeOf()",
          "slug": "object-getprototypeof"
        },
        {
          "level": 2,
          "title": "Object.keys()，Object.values()，Object.entries()",
          "slug": "object-keys-object-values-object-entries"
        },
        {
          "level": 3,
          "title": "Object.keys()",
          "slug": "object-keys"
        },
        {
          "level": 3,
          "title": "Object.values()",
          "slug": "object-values"
        },
        {
          "level": 3,
          "title": "Object.entries()",
          "slug": "object-entries"
        },
        {
          "level": 2,
          "title": "Object.fromEntries()",
          "slug": "object-fromentries"
        }
      ],
      "excerpt": "<h1 id=\"对象的新增方法\"><a class=\"header-anchor\" href=\"#对象的新增方法\">#</a> 对象的新增方法</h1>\n<p>本章介绍 Object 对象的新增方法。</p>\n<h2 id=\"object-is\"><a class=\"header-anchor\" href=\"#object-is\">#</a> Object.is()</h2>\n<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\n"
    },
    {
      "title": "Symbol",
      "frontmatter": {
        "title": "Symbol",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/02c86eb2792f3262",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/12.Symbol.html",
      "relativePath": "blogs/《ES6 教程》笔记/12.Symbol.md",
      "key": "v-b76c5fe0",
      "path": "/pages/02c86eb2792f3262/",
      "headers": [
        {
          "level": 2,
          "title": "概述",
          "slug": "概述"
        },
        {
          "level": 2,
          "title": "Symbol.prototype.description",
          "slug": "symbol-prototype-description"
        },
        {
          "level": 2,
          "title": "作为属性名的 Symbol",
          "slug": "作为属性名的-symbol"
        },
        {
          "level": 2,
          "title": "实例：消除魔术字符串",
          "slug": "实例-消除魔术字符串"
        },
        {
          "level": 2,
          "title": "属性名的遍历",
          "slug": "属性名的遍历"
        },
        {
          "level": 2,
          "title": "Symbol.for()，Symbol.keyFor()",
          "slug": "symbol-for-symbol-keyfor"
        },
        {
          "level": 2,
          "title": "实例：模块的 Singleton 模式",
          "slug": "实例-模块的-singleton-模式"
        },
        {
          "level": 2,
          "title": "内置的 Symbol 值",
          "slug": "内置的-symbol-值"
        },
        {
          "level": 3,
          "title": "Symbol.hasInstance",
          "slug": "symbol-hasinstance"
        },
        {
          "level": 3,
          "title": "Symbol.isConcatSpreadable",
          "slug": "symbol-isconcatspreadable"
        },
        {
          "level": 3,
          "title": "Symbol.species",
          "slug": "symbol-species"
        },
        {
          "level": 3,
          "title": "Symbol.match",
          "slug": "symbol-match"
        },
        {
          "level": 3,
          "title": "Symbol.replace",
          "slug": "symbol-replace"
        },
        {
          "level": 3,
          "title": "Symbol.search",
          "slug": "symbol-search"
        },
        {
          "level": 3,
          "title": "Symbol.split",
          "slug": "symbol-split"
        },
        {
          "level": 3,
          "title": "Symbol.iterator",
          "slug": "symbol-iterator"
        },
        {
          "level": 3,
          "title": "Symbol.toPrimitive",
          "slug": "symbol-toprimitive"
        },
        {
          "level": 3,
          "title": "Symbol.toStringTag",
          "slug": "symbol-tostringtag"
        },
        {
          "level": 3,
          "title": "Symbol.unscopables",
          "slug": "symbol-unscopables"
        }
      ],
      "excerpt": "<h1 id=\"symbol\"><a class=\"header-anchor\" href=\"#symbol\">#</a> Symbol</h1>\n<h2 id=\"概述\"><a class=\"header-anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，<strong>保证每个属性的名字都是独一无二</strong>的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>\n"
    },
    {
      "title": "Set 和 Map 数据结构",
      "frontmatter": {
        "title": "Set 和 Map 数据结构",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/0c21dae358fca16b",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/13.Set%20%E5%92%8C%20Map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",
      "relativePath": "blogs/《ES6 教程》笔记/13.Set 和 Map 数据结构.md",
      "key": "v-2b5169de",
      "path": "/pages/0c21dae358fca16b/",
      "headers": [
        {
          "level": 2,
          "title": "Set",
          "slug": "set"
        },
        {
          "level": 3,
          "title": "基本用法",
          "slug": "基本用法"
        },
        {
          "level": 3,
          "title": "Set 实例的属性和方法",
          "slug": "set-实例的属性和方法"
        },
        {
          "level": 3,
          "title": "遍历操作",
          "slug": "遍历操作"
        },
        {
          "level": 2,
          "title": "WeakSet",
          "slug": "weakset"
        },
        {
          "level": 3,
          "title": "含义",
          "slug": "含义"
        },
        {
          "level": 3,
          "title": "语法",
          "slug": "语法"
        },
        {
          "level": 2,
          "title": "Map",
          "slug": "map"
        },
        {
          "level": 3,
          "title": "含义和基本用法",
          "slug": "含义和基本用法"
        },
        {
          "level": 3,
          "title": "实例的属性和操作方法",
          "slug": "实例的属性和操作方法"
        },
        {
          "level": 3,
          "title": "遍历方法",
          "slug": "遍历方法"
        },
        {
          "level": 3,
          "title": "与其他数据结构的互相转换",
          "slug": "与其他数据结构的互相转换"
        },
        {
          "level": 2,
          "title": "WeakMap",
          "slug": "weakmap"
        },
        {
          "level": 3,
          "title": "含义",
          "slug": "含义-2"
        },
        {
          "level": 3,
          "title": "WeakMap 的语法",
          "slug": "weakmap-的语法"
        },
        {
          "level": 3,
          "title": "WeakMap 的示例",
          "slug": "weakmap-的示例"
        },
        {
          "level": 3,
          "title": "WeakMap 的用途",
          "slug": "weakmap-的用途"
        }
      ],
      "excerpt": "<h1 id=\"set-和-map-数据结构\"><a class=\"header-anchor\" href=\"#set-和-map-数据结构\">#</a> Set 和 Map 数据结构</h1>\n<h2 id=\"set\"><a class=\"header-anchor\" href=\"#set\">#</a> Set</h2>\n<h3 id=\"基本用法\"><a class=\"header-anchor\" href=\"#基本用法\">#</a> 基本用法</h3>\n<p>ES6 提供了新的数据结构 Set。它<strong>类似于数组，但是成员的值都是唯一的，没有重复的值</strong>。</p>\n<p><strong><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</strong>。</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">const</span> s <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> s<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token keyword\">of</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 2 3 5 4</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br></div><!--beforeend--></div><!--afterend-->"
    },
    {
      "title": "Reflect",
      "frontmatter": {
        "title": "Reflect",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/74de3e45e4491e95",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/15.Reflect.html",
      "relativePath": "blogs/《ES6 教程》笔记/15.Reflect.md",
      "key": "v-e63e0d48",
      "path": "/pages/74de3e45e4491e95/",
      "headers": [
        {
          "level": 2,
          "title": "概述",
          "slug": "概述"
        },
        {
          "level": 2,
          "title": "静态方法",
          "slug": "静态方法"
        },
        {
          "level": 3,
          "title": "Reflect.get(target, name, receiver)",
          "slug": "reflect-get-target-name-receiver"
        },
        {
          "level": 3,
          "title": "Reflect.set(target, name, value, receiver)",
          "slug": "reflect-set-target-name-value-receiver"
        },
        {
          "level": 3,
          "title": "Reflect.has(obj, name)",
          "slug": "reflect-has-obj-name"
        },
        {
          "level": 3,
          "title": "Reflect.deleteProperty(obj, name)",
          "slug": "reflect-deleteproperty-obj-name"
        },
        {
          "level": 3,
          "title": "Reflect.construct(target, args)",
          "slug": "reflect-construct-target-args"
        },
        {
          "level": 3,
          "title": "Reflect.getPrototypeOf(obj)",
          "slug": "reflect-getprototypeof-obj"
        },
        {
          "level": 3,
          "title": "Reflect.setPrototypeOf(obj, newProto)",
          "slug": "reflect-setprototypeof-obj-newproto"
        },
        {
          "level": 3,
          "title": "Reflect.apply(func, thisArg, args)",
          "slug": "reflect-apply-func-thisarg-args"
        },
        {
          "level": 3,
          "title": "Reflect.defineProperty(target, propertyKey, attributes)",
          "slug": "reflect-defineproperty-target-propertykey-attributes"
        },
        {
          "level": 3,
          "title": "Reflect.getOwnPropertyDescriptor(target, propertyKey)",
          "slug": "reflect-getownpropertydescriptor-target-propertykey"
        },
        {
          "level": 3,
          "title": "Reflect.isExtensible (target)",
          "slug": "reflect-isextensible-target"
        },
        {
          "level": 3,
          "title": "Reflect.preventExtensions(target)",
          "slug": "reflect-preventextensions-target"
        },
        {
          "level": 3,
          "title": "Reflect.ownKeys (target)",
          "slug": "reflect-ownkeys-target"
        },
        {
          "level": 2,
          "title": "实例：使用 Proxy 实现观察者模式",
          "slug": "实例-使用-proxy-实现观察者模式"
        }
      ],
      "excerpt": "<h1 id=\"reflect\"><a class=\"header-anchor\" href=\"#reflect\">#</a> Reflect</h1>\n<h2 id=\"概述\"><a class=\"header-anchor\" href=\"#概述\">#</a> 概述</h2>\n<p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\n<p>（1） **将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。**现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>\n"
    },
    {
      "title": "Iterator 和 for-of 循环",
      "frontmatter": {
        "title": "Iterator 和 for-of 循环",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/48df907ad3570f3d",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/17.Iterator%20%E5%92%8C%20for-of%20%E5%BE%AA%E7%8E%AF.html",
      "relativePath": "blogs/《ES6 教程》笔记/17.Iterator 和 for-of 循环.md",
      "key": "v-13d78db2",
      "path": "/pages/48df907ad3570f3d/",
      "headers": [
        {
          "level": 2,
          "title": "Iterator（遍历器）的概念",
          "slug": "iterator-遍历器-的概念"
        },
        {
          "level": 2,
          "title": "默认 Iterator 接口",
          "slug": "默认-iterator-接口"
        },
        {
          "level": 2,
          "title": "调用 Iterator 接口的场合",
          "slug": "调用-iterator-接口的场合"
        },
        {
          "level": 2,
          "title": "字符串的 Iterator 接口",
          "slug": "字符串的-iterator-接口"
        },
        {
          "level": 2,
          "title": "Iterator 接口与 Generator 函数",
          "slug": "iterator-接口与-generator-函数"
        },
        {
          "level": 2,
          "title": "遍历器对象的 return()，throw()",
          "slug": "遍历器对象的-return-throw"
        },
        {
          "level": 2,
          "title": "for...of 循环",
          "slug": "for-of-循环"
        },
        {
          "level": 3,
          "title": "数组",
          "slug": "数组"
        },
        {
          "level": 3,
          "title": "Set 和 Map 结构",
          "slug": "set-和-map-结构"
        },
        {
          "level": 3,
          "title": "计算生成的数据结构",
          "slug": "计算生成的数据结构"
        },
        {
          "level": 3,
          "title": "类似数组的对象",
          "slug": "类似数组的对象"
        },
        {
          "level": 3,
          "title": "对象",
          "slug": "对象"
        },
        {
          "level": 3,
          "title": "与其他遍历语法的比较",
          "slug": "与其他遍历语法的比较"
        }
      ],
      "excerpt": "<h1 id=\"iterator-和-for-of-循环\"><a class=\"header-anchor\" href=\"#iterator-和-for-of-循环\">#</a> Iterator 和 for...of 循环</h1>\n<h2 id=\"iterator-遍历器-的概念\"><a class=\"header-anchor\" href=\"#iterator-遍历器-的概念\">#</a> Iterator（遍历器）的概念</h2>\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\n"
    },
    {
      "title": "Proxy",
      "frontmatter": {
        "title": "Proxy",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/f56ec2ab97d60483",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/14.Proxy.html",
      "relativePath": "blogs/《ES6 教程》笔记/14.Proxy.md",
      "key": "v-6a432548",
      "path": "/pages/f56ec2ab97d60483/",
      "headers": [
        {
          "level": 2,
          "title": "概述",
          "slug": "概述"
        },
        {
          "level": 2,
          "title": "Proxy 实例的方法",
          "slug": "proxy-实例的方法"
        },
        {
          "level": 3,
          "title": "get()",
          "slug": "get"
        },
        {
          "level": 3,
          "title": "set()",
          "slug": "set"
        },
        {
          "level": 3,
          "title": "apply()",
          "slug": "apply"
        },
        {
          "level": 3,
          "title": "has()",
          "slug": "has"
        },
        {
          "level": 3,
          "title": "construct()",
          "slug": "construct"
        },
        {
          "level": 3,
          "title": "deleteProperty()",
          "slug": "deleteproperty"
        },
        {
          "level": 3,
          "title": "defineProperty()",
          "slug": "defineproperty"
        },
        {
          "level": 3,
          "title": "getOwnPropertyDescriptor()",
          "slug": "getownpropertydescriptor"
        },
        {
          "level": 3,
          "title": "getPrototypeOf()",
          "slug": "getprototypeof"
        },
        {
          "level": 3,
          "title": "isExtensible()",
          "slug": "isextensible"
        },
        {
          "level": 3,
          "title": "ownKeys()",
          "slug": "ownkeys"
        },
        {
          "level": 3,
          "title": "preventExtensions()",
          "slug": "preventextensions"
        },
        {
          "level": 3,
          "title": "setPrototypeOf()",
          "slug": "setprototypeof"
        },
        {
          "level": 2,
          "title": "Proxy.revocable()",
          "slug": "proxy-revocable"
        },
        {
          "level": 2,
          "title": "this 问题",
          "slug": "this-问题"
        },
        {
          "level": 2,
          "title": "实例：Web 服务的客户端",
          "slug": "实例-web-服务的客户端"
        }
      ],
      "excerpt": "<h1 id=\"proxy\"><a class=\"header-anchor\" href=\"#proxy\">#</a> Proxy</h1>\n<h2 id=\"概述\"><a class=\"header-anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“<strong>元编程</strong>”（meta programming），即<strong>对编程语言进行编程</strong>。</p>\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，<strong>外界对该对象的访问，都必须先通过这层拦截</strong>，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\n"
    },
    {
      "title": "Promise 对象",
      "frontmatter": {
        "title": "Promise 对象",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/2810ae8985e9bd52",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/16.Promise%20%E5%AF%B9%E8%B1%A1.html",
      "relativePath": "blogs/《ES6 教程》笔记/16.Promise 对象.md",
      "key": "v-438860be",
      "path": "/pages/2810ae8985e9bd52/",
      "headers": [
        {
          "level": 2,
          "title": "Promise 的含义",
          "slug": "promise-的含义"
        },
        {
          "level": 2,
          "title": "基本用法",
          "slug": "基本用法"
        },
        {
          "level": 2,
          "title": "Promise.prototype.then()",
          "slug": "promise-prototype-then"
        },
        {
          "level": 2,
          "title": "Promise.prototype.catch()",
          "slug": "promise-prototype-catch"
        },
        {
          "level": 2,
          "title": "Promise.prototype.finally()",
          "slug": "promise-prototype-finally"
        },
        {
          "level": 2,
          "title": "Promise.all()",
          "slug": "promise-all"
        },
        {
          "level": 2,
          "title": "Promise.race()",
          "slug": "promise-race"
        },
        {
          "level": 2,
          "title": "Promise.allSettled()",
          "slug": "promise-allsettled"
        },
        {
          "level": 2,
          "title": "Promise.any()",
          "slug": "promise-any"
        },
        {
          "level": 2,
          "title": "Promise.resolve()",
          "slug": "promise-resolve"
        },
        {
          "level": 2,
          "title": "Promise.reject()",
          "slug": "promise-reject"
        },
        {
          "level": 2,
          "title": "应用",
          "slug": "应用"
        },
        {
          "level": 3,
          "title": "加载图片",
          "slug": "加载图片"
        },
        {
          "level": 3,
          "title": "Generator 函数与 Promise 的结合",
          "slug": "generator-函数与-promise-的结合"
        },
        {
          "level": 2,
          "title": "Promise.try()",
          "slug": "promise-try"
        }
      ],
      "excerpt": "<h1 id=\"promise-对象\"><a class=\"header-anchor\" href=\"#promise-对象\">#</a> Promise 对象</h1>\n<h2 id=\"promise-的含义\"><a class=\"header-anchor\" href=\"#promise-的含义\">#</a> Promise 的含义</h2>\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\n"
    },
    {
      "title": "Generator 函数的异步应用",
      "frontmatter": {
        "title": "Generator 函数的异步应用",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/75af7031eb66847b",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/19.Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8.html",
      "relativePath": "blogs/《ES6 教程》笔记/19.Generator 函数的异步应用.md",
      "key": "v-6cc3cc1e",
      "path": "/pages/75af7031eb66847b/",
      "headers": [
        {
          "level": 2,
          "title": "传统方法",
          "slug": "传统方法"
        },
        {
          "level": 2,
          "title": "基本概念",
          "slug": "基本概念"
        },
        {
          "level": 3,
          "title": "异步",
          "slug": "异步"
        },
        {
          "level": 3,
          "title": "回调函数",
          "slug": "回调函数"
        },
        {
          "level": 3,
          "title": "Promise",
          "slug": "promise"
        },
        {
          "level": 2,
          "title": "Generator 函数",
          "slug": "generator-函数"
        },
        {
          "level": 3,
          "title": "协程",
          "slug": "协程"
        },
        {
          "level": 3,
          "title": "协程的 Generator 函数实现",
          "slug": "协程的-generator-函数实现"
        },
        {
          "level": 3,
          "title": "Generator 函数的数据交换和错误处理",
          "slug": "generator-函数的数据交换和错误处理"
        },
        {
          "level": 3,
          "title": "异步任务的封装",
          "slug": "异步任务的封装"
        },
        {
          "level": 2,
          "title": "Thunk 函数",
          "slug": "thunk-函数"
        },
        {
          "level": 3,
          "title": "参数的求值策略",
          "slug": "参数的求值策略"
        },
        {
          "level": 3,
          "title": "Thunk 函数的含义",
          "slug": "thunk-函数的含义"
        },
        {
          "level": 3,
          "title": "JavaScript 语言的 Thunk 函数",
          "slug": "javascript-语言的-thunk-函数"
        },
        {
          "level": 3,
          "title": "Thunkify 模块",
          "slug": "thunkify-模块"
        },
        {
          "level": 3,
          "title": "Generator 函数的流程管理",
          "slug": "generator-函数的流程管理"
        },
        {
          "level": 3,
          "title": "Thunk 函数的自动流程管理",
          "slug": "thunk-函数的自动流程管理"
        },
        {
          "level": 2,
          "title": "co 模块",
          "slug": "co-模块"
        },
        {
          "level": 3,
          "title": "基本用法",
          "slug": "基本用法"
        },
        {
          "level": 3,
          "title": "co 模块的原理",
          "slug": "co-模块的原理"
        },
        {
          "level": 3,
          "title": "基于 Promise 对象的自动执行",
          "slug": "基于-promise-对象的自动执行"
        },
        {
          "level": 3,
          "title": "co 模块的源码",
          "slug": "co-模块的源码"
        },
        {
          "level": 3,
          "title": "处理并发的异步操作",
          "slug": "处理并发的异步操作"
        },
        {
          "level": 3,
          "title": "实例：处理 Stream",
          "slug": "实例-处理-stream"
        }
      ],
      "excerpt": "<h1 id=\"generator-函数的异步应用\"><a class=\"header-anchor\" href=\"#generator-函数的异步应用\">#</a> Generator 函数的异步应用</h1>\n<p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p>\n"
    },
    {
      "title": "Generator 函数的语法",
      "frontmatter": {
        "title": "Generator 函数的语法",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/718b48ed9ce0adce",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/18.Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95.html",
      "relativePath": "blogs/《ES6 教程》笔记/18.Generator 函数的语法.md",
      "key": "v-01d7a7b2",
      "path": "/pages/718b48ed9ce0adce/",
      "headers": [
        {
          "level": 2,
          "title": "简介",
          "slug": "简介"
        },
        {
          "level": 3,
          "title": "基本概念",
          "slug": "基本概念"
        },
        {
          "level": 3,
          "title": "yield 表达式",
          "slug": "yield-表达式"
        },
        {
          "level": 3,
          "title": "与 Iterator 接口的关系",
          "slug": "与-iterator-接口的关系"
        },
        {
          "level": 2,
          "title": "next 方法的参数",
          "slug": "next-方法的参数"
        },
        {
          "level": 2,
          "title": "for...of 循环",
          "slug": "for-of-循环"
        },
        {
          "level": 2,
          "title": "Generator.prototype.throw()",
          "slug": "generator-prototype-throw"
        },
        {
          "level": 2,
          "title": "Generator.prototype.return()",
          "slug": "generator-prototype-return"
        },
        {
          "level": 2,
          "title": "next()、throw()、return() 的共同点",
          "slug": "next-、throw-、return-的共同点"
        },
        {
          "level": 2,
          "title": "yield* 表达式",
          "slug": "yield-表达式-2"
        },
        {
          "level": 2,
          "title": "作为对象属性的 Generator 函数",
          "slug": "作为对象属性的-generator-函数"
        },
        {
          "level": 2,
          "title": "Generator 函数的this",
          "slug": "generator-函数的this"
        },
        {
          "level": 2,
          "title": "含义",
          "slug": "含义"
        },
        {
          "level": 3,
          "title": "Generator 与状态机",
          "slug": "generator-与状态机"
        },
        {
          "level": 3,
          "title": "Generator 与协程",
          "slug": "generator-与协程"
        },
        {
          "level": 3,
          "title": "Generator 与上下文",
          "slug": "generator-与上下文"
        },
        {
          "level": 2,
          "title": "应用",
          "slug": "应用"
        },
        {
          "level": 3,
          "title": "（1）异步操作的同步化表达",
          "slug": "_1-异步操作的同步化表达"
        },
        {
          "level": 3,
          "title": "（2）控制流管理",
          "slug": "_2-控制流管理"
        },
        {
          "level": 3,
          "title": "（3）部署 Iterator 接口",
          "slug": "_3-部署-iterator-接口"
        },
        {
          "level": 3,
          "title": "（4）作为数据结构",
          "slug": "_4-作为数据结构"
        }
      ],
      "excerpt": "<h1 id=\"generator-函数的语法\"><a class=\"header-anchor\" href=\"#generator-函数的语法\">#</a> Generator 函数的语法</h1>\n<h2 id=\"简介\"><a class=\"header-anchor\" href=\"#简介\">#</a> 简介</h2>\n<h3 id=\"基本概念\"><a class=\"header-anchor\" href=\"#基本概念\">#</a> 基本概念</h3>\n<p>Generator 函数是 ES6 提供的一种<strong>异步编程解决方案</strong>，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>\n"
    },
    {
      "title": "async 函数",
      "frontmatter": {
        "title": "async 函数",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/3777253e65bac487",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/20.async%20%E5%87%BD%E6%95%B0.html",
      "relativePath": "blogs/《ES6 教程》笔记/20.async 函数.md",
      "key": "v-12a8e728",
      "path": "/pages/3777253e65bac487/",
      "headers": [
        {
          "level": 2,
          "title": "含义",
          "slug": "含义"
        },
        {
          "level": 2,
          "title": "基本用法",
          "slug": "基本用法"
        },
        {
          "level": 2,
          "title": "语法",
          "slug": "语法"
        },
        {
          "level": 3,
          "title": "返回 Promise 对象",
          "slug": "返回-promise-对象"
        },
        {
          "level": 3,
          "title": "Promise 对象的状态变化",
          "slug": "promise-对象的状态变化"
        },
        {
          "level": 3,
          "title": "await 命令",
          "slug": "await-命令"
        },
        {
          "level": 3,
          "title": "错误处理",
          "slug": "错误处理"
        },
        {
          "level": 3,
          "title": "使用注意点",
          "slug": "使用注意点"
        },
        {
          "level": 2,
          "title": "async 函数的实现原理",
          "slug": "async-函数的实现原理"
        },
        {
          "level": 2,
          "title": "与其他异步处理方法的比较",
          "slug": "与其他异步处理方法的比较"
        },
        {
          "level": 2,
          "title": "实例：按顺序完成异步操作",
          "slug": "实例-按顺序完成异步操作"
        },
        {
          "level": 2,
          "title": "顶层 await",
          "slug": "顶层-await"
        }
      ],
      "excerpt": "<h1 id=\"async-函数\"><a class=\"header-anchor\" href=\"#async-函数\">#</a> async 函数</h1>\n<h2 id=\"含义\"><a class=\"header-anchor\" href=\"#含义\">#</a> 含义</h2>\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\n<p>async 函数是什么？一句话，它就<strong>是 Generator 函数的语法糖</strong>。</p>\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\n"
    },
    {
      "title": "Class 的基本语法",
      "frontmatter": {
        "title": "Class 的基本语法",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/e831e1593c82bbe0",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/21.Class%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html",
      "relativePath": "blogs/《ES6 教程》笔记/21.Class 的基本语法.md",
      "key": "v-47b76100",
      "path": "/pages/e831e1593c82bbe0/",
      "headers": [
        {
          "level": 2,
          "title": "简介",
          "slug": "简介"
        },
        {
          "level": 3,
          "title": "类的由来",
          "slug": "类的由来"
        },
        {
          "level": 3,
          "title": "constructor 方法",
          "slug": "constructor-方法"
        },
        {
          "level": 3,
          "title": "类的实例",
          "slug": "类的实例"
        },
        {
          "level": 3,
          "title": "取值函数（getter）和存值函数（setter）",
          "slug": "取值函数-getter-和存值函数-setter"
        },
        {
          "level": 3,
          "title": "属性表达式",
          "slug": "属性表达式"
        },
        {
          "level": 3,
          "title": "Class 表达式",
          "slug": "class-表达式"
        },
        {
          "level": 3,
          "title": "注意点",
          "slug": "注意点"
        },
        {
          "level": 2,
          "title": "静态方法",
          "slug": "静态方法"
        },
        {
          "level": 2,
          "title": "实例属性的新写法",
          "slug": "实例属性的新写法"
        },
        {
          "level": 2,
          "title": "静态属性",
          "slug": "静态属性"
        },
        {
          "level": 2,
          "title": "私有方法和私有属性",
          "slug": "私有方法和私有属性"
        },
        {
          "level": 3,
          "title": "现有的解决方案",
          "slug": "现有的解决方案"
        },
        {
          "level": 3,
          "title": "私有属性的提案",
          "slug": "私有属性的提案"
        },
        {
          "level": 2,
          "title": "new.target 属性",
          "slug": "new-target-属性"
        }
      ],
      "excerpt": "<h1 id=\"class-的基本语法\"><a class=\"header-anchor\" href=\"#class-的基本语法\">#</a> Class 的基本语法</h1>\n<h2 id=\"简介\"><a class=\"header-anchor\" href=\"#简介\">#</a> 简介</h2>\n<h3 id=\"类的由来\"><a class=\"header-anchor\" href=\"#类的由来\">#</a> 类的由来</h3>\n<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">Point</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">Point</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">toString</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">\"(\"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">+</span> <span class=\"token string\">\", \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">+</span> <span class=\"token string\">\")\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Point</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br><span class=\"line-number\">10</span><br></div><!--beforeend--></div><!--afterend-->"
    },
    {
      "title": "Class 的继承",
      "frontmatter": {
        "title": "Class 的继承",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/83f8c3a0cd87dd83",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/22.Class%20%E7%9A%84%E7%BB%A7%E6%89%BF.html",
      "relativePath": "blogs/《ES6 教程》笔记/22.Class 的继承.md",
      "key": "v-39f253f8",
      "path": "/pages/83f8c3a0cd87dd83/",
      "headers": [
        {
          "level": 2,
          "title": "简介",
          "slug": "简介"
        },
        {
          "level": 2,
          "title": "Object.getPrototypeOf()",
          "slug": "object-getprototypeof"
        },
        {
          "level": 2,
          "title": "super 关键字",
          "slug": "super-关键字"
        },
        {
          "level": 2,
          "title": "类的 prototype 属性和__proto__属性",
          "slug": "类的-prototype-属性和-proto-属性"
        },
        {
          "level": 3,
          "title": "实例的 __proto__ 属性",
          "slug": "实例的-proto-属性"
        },
        {
          "level": 2,
          "title": "原生构造函数的继承",
          "slug": "原生构造函数的继承"
        },
        {
          "level": 2,
          "title": "Mixin 模式的实现",
          "slug": "mixin-模式的实现"
        }
      ],
      "excerpt": "<h1 id=\"class-的继承\"><a class=\"header-anchor\" href=\"#class-的继承\">#</a> Class 的继承</h1>\n<h2 id=\"简介\"><a class=\"header-anchor\" href=\"#简介\">#</a> 简介</h2>\n<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">Point</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ColorPoint</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Point</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br></div><!--beforeend--></div><!--afterend-->"
    },
    {
      "title": "Module 的语法",
      "frontmatter": {
        "title": "Module 的语法",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/efe2fb04eb8ac5fb",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/23.Module%20%E7%9A%84%E8%AF%AD%E6%B3%95.html",
      "relativePath": "blogs/《ES6 教程》笔记/23.Module 的语法.md",
      "key": "v-737f22ee",
      "path": "/pages/efe2fb04eb8ac5fb/",
      "headers": [
        {
          "level": 2,
          "title": "概述",
          "slug": "概述"
        },
        {
          "level": 2,
          "title": "严格模式",
          "slug": "严格模式"
        },
        {
          "level": 2,
          "title": "export 命令",
          "slug": "export-命令"
        },
        {
          "level": 2,
          "title": "import 命令",
          "slug": "import-命令"
        },
        {
          "level": 2,
          "title": "模块的整体加载-(星号*)",
          "slug": "模块的整体加载-星号"
        },
        {
          "level": 2,
          "title": "export default 命令",
          "slug": "export-default-命令"
        },
        {
          "level": 2,
          "title": "export 与 import 的复合写法",
          "slug": "export-与-import-的复合写法"
        },
        {
          "level": 2,
          "title": "模块的继承",
          "slug": "模块的继承"
        },
        {
          "level": 2,
          "title": "跨模块常量",
          "slug": "跨模块常量"
        },
        {
          "level": 2,
          "title": "import()",
          "slug": "import"
        },
        {
          "level": 3,
          "title": "简介",
          "slug": "简介"
        },
        {
          "level": 3,
          "title": "适用场合",
          "slug": "适用场合"
        },
        {
          "level": 3,
          "title": "注意点",
          "slug": "注意点"
        }
      ],
      "excerpt": "<h1 id=\"module-的语法\"><a class=\"header-anchor\" href=\"#module-的语法\">#</a> Module 的语法</h1>\n<h2 id=\"概述\"><a class=\"header-anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\n"
    },
    {
      "title": "Module 的加载实现",
      "frontmatter": {
        "title": "Module 的加载实现",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/a79ca2e64ceae213",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/24.Module%20%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0.html",
      "relativePath": "blogs/《ES6 教程》笔记/24.Module 的加载实现.md",
      "key": "v-1e548237",
      "path": "/pages/a79ca2e64ceae213/",
      "headers": [
        {
          "level": 2,
          "title": "浏览器加载",
          "slug": "浏览器加载"
        },
        {
          "level": 3,
          "title": "传统方法",
          "slug": "传统方法"
        },
        {
          "level": 3,
          "title": "加载规则",
          "slug": "加载规则"
        },
        {
          "level": 2,
          "title": "ES6 模块与 CommonJS 模块的差异",
          "slug": "es6-模块与-commonjs-模块的差异"
        },
        {
          "level": 2,
          "title": "Node.js 加载",
          "slug": "node-js-加载"
        },
        {
          "level": 3,
          "title": "概述",
          "slug": "概述"
        },
        {
          "level": 3,
          "title": "main 字段",
          "slug": "main-字段"
        },
        {
          "level": 3,
          "title": "exports 字段",
          "slug": "exports-字段"
        },
        {
          "level": 3,
          "title": "ES6 模块加载 CommonJS 模块",
          "slug": "es6-模块加载-commonjs-模块"
        },
        {
          "level": 3,
          "title": "CommonJS 模块加载 ES6 模块",
          "slug": "commonjs-模块加载-es6-模块"
        },
        {
          "level": 3,
          "title": "Node.js 的内置模块",
          "slug": "node-js-的内置模块"
        },
        {
          "level": 3,
          "title": "加载路径",
          "slug": "加载路径"
        },
        {
          "level": 3,
          "title": "内部变量",
          "slug": "内部变量"
        },
        {
          "level": 2,
          "title": "循环加载",
          "slug": "循环加载"
        },
        {
          "level": 3,
          "title": "CommonJS 模块的加载原理",
          "slug": "commonjs-模块的加载原理"
        },
        {
          "level": 3,
          "title": "CommonJS 模块的循环加载",
          "slug": "commonjs-模块的循环加载"
        },
        {
          "level": 3,
          "title": "ES6 模块的循环加载",
          "slug": "es6-模块的循环加载"
        }
      ],
      "excerpt": "<h1 id=\"module-的加载实现\"><a class=\"header-anchor\" href=\"#module-的加载实现\">#</a> Module 的加载实现</h1>\n<p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p>\n"
    },
    {
      "title": "读懂 ECMAScript 规格",
      "frontmatter": {
        "title": "读懂 ECMAScript 规格",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/32c35f7651d6e58e",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/26.%E8%AF%BB%E6%87%82%20ECMAScript%20%E8%A7%84%E6%A0%BC.html",
      "relativePath": "blogs/《ES6 教程》笔记/26.读懂 ECMAScript 规格.md",
      "key": "v-c983e98e",
      "path": "/pages/32c35f7651d6e58e/",
      "headers": [
        {
          "level": 2,
          "title": "概述",
          "slug": "概述"
        },
        {
          "level": 2,
          "title": "术语",
          "slug": "术语"
        },
        {
          "level": 3,
          "title": "抽象操作",
          "slug": "抽象操作"
        },
        {
          "level": 3,
          "title": "Record 和 field",
          "slug": "record-和-field"
        },
        {
          "level": 3,
          "title": "[[Notation]]",
          "slug": "notation"
        },
        {
          "level": 3,
          "title": "Completion Record",
          "slug": "completion-record"
        },
        {
          "level": 2,
          "title": "抽象操作的标准流程",
          "slug": "抽象操作的标准流程"
        },
        {
          "level": 2,
          "title": "相等运算符",
          "slug": "相等运算符"
        },
        {
          "level": 2,
          "title": "数组的空位",
          "slug": "数组的空位"
        },
        {
          "level": 2,
          "title": "数组的 map 方法",
          "slug": "数组的-map-方法"
        }
      ],
      "excerpt": "<h1 id=\"读懂-ecmascript-规格\"><a class=\"header-anchor\" href=\"#读懂-ecmascript-规格\">#</a> 读懂 ECMAScript 规格</h1>\n<h2 id=\"概述\"><a class=\"header-anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p>\n<p>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>\n"
    },
    {
      "title": "编程风格",
      "frontmatter": {
        "title": "编程风格",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/984bf549204bb266",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/25.%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC.html",
      "relativePath": "blogs/《ES6 教程》笔记/25.编程风格.md",
      "key": "v-4c0b0454",
      "path": "/pages/984bf549204bb266/",
      "headers": [
        {
          "level": 2,
          "title": "块级作用域",
          "slug": "块级作用域"
        },
        {
          "level": 2,
          "title": "字符串",
          "slug": "字符串"
        },
        {
          "level": 2,
          "title": "解构赋值",
          "slug": "解构赋值"
        },
        {
          "level": 2,
          "title": "对象",
          "slug": "对象"
        },
        {
          "level": 2,
          "title": "数组",
          "slug": "数组"
        },
        {
          "level": 2,
          "title": "函数",
          "slug": "函数"
        },
        {
          "level": 2,
          "title": "Map 结构",
          "slug": "map-结构"
        },
        {
          "level": 2,
          "title": "Class",
          "slug": "class"
        },
        {
          "level": 2,
          "title": "模块",
          "slug": "模块"
        },
        {
          "level": 2,
          "title": "ESLint 的使用",
          "slug": "eslint-的使用"
        }
      ],
      "excerpt": "<h1 id=\"编程风格\"><a class=\"header-anchor\" href=\"#编程风格\">#</a> 编程风格</h1>\n<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p>\n<p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a href=\"https://github.com/airbnb/javascript\" target=\"_blank\" rel=\"noopener noreferrer\">Airbnb<OutboundLink/></a> 公司的 JavaScript 风格规范。</p>\n"
    },
    {
      "title": "异步遍历器",
      "frontmatter": {
        "title": "异步遍历器",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/16121351be68691b",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/27.%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8.html",
      "relativePath": "blogs/《ES6 教程》笔记/27.异步遍历器.md",
      "key": "v-31c24c4f",
      "path": "/pages/16121351be68691b/",
      "headers": [
        {
          "level": 2,
          "title": "同步遍历器的问题",
          "slug": "同步遍历器的问题"
        },
        {
          "level": 2,
          "title": "异步遍历的接口",
          "slug": "异步遍历的接口"
        },
        {
          "level": 2,
          "title": "for await...of",
          "slug": "for-await-of"
        },
        {
          "level": 2,
          "title": "异步 Generator 函数",
          "slug": "异步-generator-函数"
        },
        {
          "level": 2,
          "title": "yield* 语句",
          "slug": "yield-语句"
        }
      ],
      "excerpt": "<h1 id=\"异步遍历器\"><a class=\"header-anchor\" href=\"#异步遍历器\">#</a> 异步遍历器</h1>\n<h2 id=\"同步遍历器的问题\"><a class=\"header-anchor\" href=\"#同步遍历器的问题\">#</a> 同步遍历器的问题</h2>\n<p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\n"
    },
    {
      "title": "最新提案",
      "frontmatter": {
        "title": "最新提案",
        "date": "2020-02-09T16:00:30.000Z",
        "permalink": "/pages/7188882b8d65af1b",
        "author": "Yang J.K",
        "sticky": 1,
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/29.%E6%9C%80%E6%96%B0%E6%8F%90%E6%A1%88.html",
      "relativePath": "blogs/《ES6 教程》笔记/29.最新提案.md",
      "key": "v-49abbeba",
      "path": "/pages/7188882b8d65af1b/",
      "headers": [
        {
          "level": 2,
          "title": "do 表达式",
          "slug": "do-表达式"
        },
        {
          "level": 2,
          "title": "throw 表达式",
          "slug": "throw-表达式"
        },
        {
          "level": 2,
          "title": "函数的部分执行",
          "slug": "函数的部分执行"
        },
        {
          "level": 3,
          "title": "语法",
          "slug": "语法"
        },
        {
          "level": 3,
          "title": "注意点",
          "slug": "注意点"
        },
        {
          "level": 2,
          "title": "管道运算符",
          "slug": "管道运算符"
        },
        {
          "level": 2,
          "title": "数值分隔符",
          "slug": "数值分隔符"
        },
        {
          "level": 2,
          "title": "Math.signbit()",
          "slug": "math-signbit"
        },
        {
          "level": 2,
          "title": "双冒号运算符",
          "slug": "双冒号运算符"
        },
        {
          "level": 2,
          "title": "Realm API",
          "slug": "realm-api"
        },
        {
          "level": 2,
          "title": "#!命令",
          "slug": "命令"
        },
        {
          "level": 2,
          "title": "import.meta",
          "slug": "import-meta"
        }
      ],
      "excerpt": "<h1 id=\"最新提案\"><a class=\"header-anchor\" href=\"#最新提案\">#</a> 最新提案</h1>\n<p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p>\n<h2 id=\"do-表达式\"><a class=\"header-anchor\" href=\"#do-表达式\">#</a> do 表达式</h2>\n<p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> t <span class=\"token operator\">=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  t <span class=\"token operator\">=</span> t <span class=\"token operator\">*</span> t <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br></div><!--beforeend--></div><!--afterend-->"
    },
    {
      "title": "函数式编程",
      "frontmatter": {
        "title": "函数式编程",
        "date": "2020-02-09T16:00:30.000Z",
        "permalink": "/pages/1cf50330655efc69",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/31.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html",
      "relativePath": "blogs/《ES6 教程》笔记/31.函数式编程.md",
      "key": "v-2f750624",
      "path": "/pages/1cf50330655efc69/",
      "headers": [
        {
          "level": 2,
          "title": "柯里化",
          "slug": "柯里化"
        },
        {
          "level": 2,
          "title": "函数合成",
          "slug": "函数合成"
        },
        {
          "level": 2,
          "title": "参数倒置",
          "slug": "参数倒置"
        },
        {
          "level": 2,
          "title": "执行边界",
          "slug": "执行边界"
        },
        {
          "level": 2,
          "title": "队列操作",
          "slug": "队列操作"
        },
        {
          "level": 2,
          "title": "合并操作",
          "slug": "合并操作"
        },
        {
          "level": 2,
          "title": "配对操作",
          "slug": "配对操作"
        },
        {
          "level": 2,
          "title": "参考链接",
          "slug": "参考链接"
        }
      ],
      "excerpt": "<h1 id=\"函数式编程\"><a class=\"header-anchor\" href=\"#函数式编程\">#</a> 函数式编程</h1>\n<p>JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。</p>\n"
    },
    {
      "title": "Mixin",
      "frontmatter": {
        "title": "Mixin",
        "date": "2020-02-09T16:00:30.000Z",
        "permalink": "/pages/6a8e2dc558da1b39",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/32.Mixin.html",
      "relativePath": "blogs/《ES6 教程》笔记/32.Mixin.md",
      "key": "v-28b5b13c",
      "path": "/pages/6a8e2dc558da1b39/",
      "headers": [
        {
          "level": 2,
          "title": "含义",
          "slug": "含义"
        },
        {
          "level": 2,
          "title": "Trait",
          "slug": "trait"
        }
      ],
      "excerpt": "<h1 id=\"mixin\"><a class=\"header-anchor\" href=\"#mixin\">#</a> Mixin</h1>\n<p>JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的<a href=\"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\" target=\"_blank\" rel=\"noopener noreferrer\">网状结构<OutboundLink/></a>。</p>\n"
    },
    {
      "title": "ArrayBuffer",
      "frontmatter": {
        "title": "ArrayBuffer",
        "date": "2020-02-09T16:00:29.000Z",
        "permalink": "/pages/a2ba314746bfdbdd",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/28.ArrayBuffer.html",
      "relativePath": "blogs/《ES6 教程》笔记/28.ArrayBuffer.md",
      "key": "v-62ed22c8",
      "path": "/pages/a2ba314746bfdbdd/",
      "headers": [
        {
          "level": 2,
          "title": "ArrayBuffer 对象",
          "slug": "arraybuffer-对象"
        },
        {
          "level": 3,
          "title": "概述",
          "slug": "概述"
        },
        {
          "level": 3,
          "title": "ArrayBuffer.prototype.byteLength",
          "slug": "arraybuffer-prototype-bytelength"
        },
        {
          "level": 3,
          "title": "ArrayBuffer.prototype.slice()",
          "slug": "arraybuffer-prototype-slice"
        },
        {
          "level": 3,
          "title": "ArrayBuffer.isView()",
          "slug": "arraybuffer-isview"
        },
        {
          "level": 2,
          "title": "TypedArray 视图",
          "slug": "typedarray-视图"
        },
        {
          "level": 3,
          "title": "概述",
          "slug": "概述-2"
        },
        {
          "level": 3,
          "title": "构造函数",
          "slug": "构造函数"
        },
        {
          "level": 3,
          "title": "数组方法",
          "slug": "数组方法"
        },
        {
          "level": 3,
          "title": "字节序",
          "slug": "字节序"
        },
        {
          "level": 3,
          "title": "BYTESPERELEMENT 属性",
          "slug": "bytes-per-element-属性"
        },
        {
          "level": 3,
          "title": "ArrayBuffer 与字符串的互相转换",
          "slug": "arraybuffer-与字符串的互相转换"
        },
        {
          "level": 3,
          "title": "溢出",
          "slug": "溢出"
        },
        {
          "level": 3,
          "title": "TypedArray.prototype.buffer",
          "slug": "typedarray-prototype-buffer"
        },
        {
          "level": 3,
          "title": "TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset",
          "slug": "typedarray-prototype-bytelength-typedarray-prototype-byteoffset"
        },
        {
          "level": 3,
          "title": "TypedArray.prototype.length",
          "slug": "typedarray-prototype-length"
        },
        {
          "level": 3,
          "title": "TypedArray.prototype.set()",
          "slug": "typedarray-prototype-set"
        },
        {
          "level": 3,
          "title": "TypedArray.prototype.subarray()",
          "slug": "typedarray-prototype-subarray"
        },
        {
          "level": 3,
          "title": "TypedArray.prototype.slice()",
          "slug": "typedarray-prototype-slice"
        },
        {
          "level": 3,
          "title": "TypedArray.of()",
          "slug": "typedarray-of"
        },
        {
          "level": 3,
          "title": "TypedArray.from()",
          "slug": "typedarray-from"
        },
        {
          "level": 2,
          "title": "复合视图",
          "slug": "复合视图"
        },
        {
          "level": 2,
          "title": "DataView 视图",
          "slug": "dataview-视图"
        },
        {
          "level": 2,
          "title": "二进制数组的应用",
          "slug": "二进制数组的应用"
        },
        {
          "level": 3,
          "title": "AJAX",
          "slug": "ajax"
        },
        {
          "level": 3,
          "title": "Canvas",
          "slug": "canvas"
        },
        {
          "level": 3,
          "title": "WebSocket",
          "slug": "websocket"
        },
        {
          "level": 3,
          "title": "Fetch API",
          "slug": "fetch-api"
        },
        {
          "level": 3,
          "title": "File API",
          "slug": "file-api"
        },
        {
          "level": 2,
          "title": "SharedArrayBuffer",
          "slug": "sharedarraybuffer"
        },
        {
          "level": 2,
          "title": "Atomics 对象",
          "slug": "atomics-对象"
        }
      ],
      "excerpt": "<h1 id=\"arraybuffer\"><a class=\"header-anchor\" href=\"#arraybuffer\">#</a> ArrayBuffer</h1>\n<p><code>ArrayBuffer</code>对象、<code>TypedArray</code>视图和<code>DataView</code>视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>\n"
    },
    {
      "title": "SIMD",
      "frontmatter": {
        "title": "SIMD",
        "date": "2020-02-09T16:00:30.000Z",
        "permalink": "/pages/8e8f80f69b775a56",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/33.SIMD.html",
      "relativePath": "blogs/《ES6 教程》笔记/33.SIMD.md",
      "key": "v-28794364",
      "path": "/pages/8e8f80f69b775a56/",
      "headers": [
        {
          "level": 2,
          "title": "概述",
          "slug": "概述"
        },
        {
          "level": 2,
          "title": "数据类型",
          "slug": "数据类型"
        },
        {
          "level": 2,
          "title": "静态方法：数学运算",
          "slug": "静态方法-数学运算"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.abs()，SIMD.%type%.neg()",
          "slug": "simd-type-abs-simd-type-neg"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.add()，SIMD.%type%.addSaturate()",
          "slug": "simd-type-add-simd-type-addsaturate"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.sub()，SIMD.%type%.subSaturate()",
          "slug": "simd-type-sub-simd-type-subsaturate"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.mul()，SIMD.%type%.div()，SIMD.%type%.sqrt()",
          "slug": "simd-type-mul-simd-type-div-simd-type-sqrt"
        },
        {
          "level": 3,
          "title": "SIMD.%FloatType%.reciprocalApproximation()，SIMD.%type%.reciprocalSqrtApproximation()",
          "slug": "simd-floattype-reciprocalapproximation-simd-type-reciprocalsqrtapproximation"
        },
        {
          "level": 3,
          "title": "SIMD.%IntegerType%.shiftLeftByScalar()",
          "slug": "simd-integertype-shiftleftbyscalar"
        },
        {
          "level": 3,
          "title": "SIMD.%IntegerType%.shiftRightByScalar()",
          "slug": "simd-integertype-shiftrightbyscalar"
        },
        {
          "level": 2,
          "title": "静态方法：通道处理",
          "slug": "静态方法-通道处理"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.check()",
          "slug": "simd-type-check"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.extractLane()，SIMD.%type%.replaceLane()",
          "slug": "simd-type-extractlane-simd-type-replacelane"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.load()",
          "slug": "simd-type-load"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.store()",
          "slug": "simd-type-store"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.splat()",
          "slug": "simd-type-splat"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.swizzle()",
          "slug": "simd-type-swizzle"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.shuffle()",
          "slug": "simd-type-shuffle"
        },
        {
          "level": 2,
          "title": "静态方法：比较运算",
          "slug": "静态方法-比较运算"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.equal()，SIMD.%type%.notEqual()",
          "slug": "simd-type-equal-simd-type-notequal"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.greaterThan()，SIMD.%type%.greaterThanOrEqual()",
          "slug": "simd-type-greaterthan-simd-type-greaterthanorequal"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.lessThan()，SIMD.%type%.lessThanOrEqual()",
          "slug": "simd-type-lessthan-simd-type-lessthanorequal"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.select()",
          "slug": "simd-type-select"
        },
        {
          "level": 3,
          "title": "SIMD.%BooleanType%.allTrue()，SIMD.%BooleanType%.anyTrue()",
          "slug": "simd-booleantype-alltrue-simd-booleantype-anytrue"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.min()，SIMD.%type%.minNum()",
          "slug": "simd-type-min-simd-type-minnum"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.max()，SIMD.%type%.maxNum()",
          "slug": "simd-type-max-simd-type-maxnum"
        },
        {
          "level": 2,
          "title": "静态方法：位运算",
          "slug": "静态方法-位运算"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.and()，SIMD.%type%.or()，SIMD.%type%.xor()，SIMD.%type%.not()",
          "slug": "simd-type-and-simd-type-or-simd-type-xor-simd-type-not"
        },
        {
          "level": 2,
          "title": "静态方法：数据类型转换",
          "slug": "静态方法-数据类型转换"
        },
        {
          "level": 2,
          "title": "实例方法",
          "slug": "实例方法"
        },
        {
          "level": 3,
          "title": "SIMD.%type%.prototype.toString()",
          "slug": "simd-type-prototype-tostring"
        },
        {
          "level": 2,
          "title": "实例：求平均值",
          "slug": "实例-求平均值"
        }
      ],
      "excerpt": "<h1 id=\"simd\"><a class=\"header-anchor\" href=\"#simd\">#</a> SIMD</h1>\n<h2 id=\"概述\"><a class=\"header-anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>SIMD（发音<code>/sim-dee/</code>）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p>\n"
    },
    {
      "title": "装饰器",
      "frontmatter": {
        "title": "装饰器",
        "date": "2020-02-09T16:00:30.000Z",
        "permalink": "/pages/e97bc1e5626b082c",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/30.%E8%A3%85%E9%A5%B0%E5%99%A8.html",
      "relativePath": "blogs/《ES6 教程》笔记/30.装饰器.md",
      "key": "v-3c35f69d",
      "path": "/pages/e97bc1e5626b082c/",
      "headers": [
        {
          "level": 2,
          "title": "类的装饰",
          "slug": "类的装饰"
        },
        {
          "level": 2,
          "title": "方法的装饰",
          "slug": "方法的装饰"
        },
        {
          "level": 2,
          "title": "为什么装饰器不能用于函数？",
          "slug": "为什么装饰器不能用于函数"
        },
        {
          "level": 2,
          "title": "core-decorators.js",
          "slug": "core-decorators-js"
        },
        {
          "level": 2,
          "title": "使用装饰器实现自动发布事件",
          "slug": "使用装饰器实现自动发布事件"
        },
        {
          "level": 2,
          "title": "Mixin",
          "slug": "mixin"
        },
        {
          "level": 2,
          "title": "Trait",
          "slug": "trait"
        }
      ],
      "excerpt": "<h1 id=\"装饰器\"><a class=\"header-anchor\" href=\"#装饰器\">#</a> 装饰器</h1>\n<p>[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。</p>\n<p>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个<a href=\"https://github.com/tc39/proposal-decorators\" target=\"_blank\" rel=\"noopener noreferrer\">提案<OutboundLink/></a>将其引入了 ECMAScript。</p>\n"
    },
    {
      "title": "参考链接",
      "frontmatter": {
        "title": "参考链接",
        "date": "2020-02-09T16:00:30.000Z",
        "permalink": "/pages/ea6f3b870f6dab69",
        "author": "Yang J.K",
        "categories": [
          "《ES6 教程》笔记"
        ],
        "tags": [
          "ES6"
        ]
      },
      "regularPath": "/blogs/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/34.%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5.html",
      "relativePath": "blogs/《ES6 教程》笔记/34.参考链接.md",
      "key": "v-6f26cac3",
      "path": "/pages/ea6f3b870f6dab69/",
      "headers": [
        {
          "level": 2,
          "title": "官方文件",
          "slug": "官方文件"
        },
        {
          "level": 2,
          "title": "综合介绍",
          "slug": "综合介绍"
        },
        {
          "level": 2,
          "title": "let 和 const",
          "slug": "let-和-const"
        },
        {
          "level": 2,
          "title": "解构赋值",
          "slug": "解构赋值"
        },
        {
          "level": 2,
          "title": "字符串",
          "slug": "字符串"
        },
        {
          "level": 2,
          "title": "正则",
          "slug": "正则"
        },
        {
          "level": 2,
          "title": "数值",
          "slug": "数值"
        },
        {
          "level": 2,
          "title": "数组",
          "slug": "数组"
        },
        {
          "level": 2,
          "title": "函数",
          "slug": "函数"
        },
        {
          "level": 2,
          "title": "对象",
          "slug": "对象"
        },
        {
          "level": 2,
          "title": "Symbol",
          "slug": "symbol"
        },
        {
          "level": 2,
          "title": "Set 和 Map",
          "slug": "set-和-map"
        },
        {
          "level": 2,
          "title": "Proxy 和 Reflect",
          "slug": "proxy-和-reflect"
        },
        {
          "level": 2,
          "title": "Promise 对象",
          "slug": "promise-对象"
        },
        {
          "level": 2,
          "title": "Iterator",
          "slug": "iterator"
        },
        {
          "level": 2,
          "title": "Generator",
          "slug": "generator"
        },
        {
          "level": 2,
          "title": "异步操作和 Async 函数",
          "slug": "异步操作和-async-函数"
        },
        {
          "level": 2,
          "title": "Class",
          "slug": "class"
        },
        {
          "level": 2,
          "title": "Decorator",
          "slug": "decorator"
        },
        {
          "level": 2,
          "title": "Module",
          "slug": "module"
        },
        {
          "level": 2,
          "title": "二进制数组",
          "slug": "二进制数组"
        },
        {
          "level": 2,
          "title": "SIMD",
          "slug": "simd"
        },
        {
          "level": 2,
          "title": "工具",
          "slug": "工具"
        }
      ]
    },
    {
      "title": "theme-reco",
      "frontmatter": {
        "title": "theme-reco",
        "date": "2020-05-29T00:00:00.000Z",
        "sticky": 1
      },
      "regularPath": "/docs/theme-reco/",
      "relativePath": "docs/theme-reco/README.md",
      "key": "v-02772db8",
      "path": "/docs/theme-reco/"
    },
    {
      "title": "api",
      "frontmatter": {
        "title": "api",
        "date": "2020-05-29T00:00:00.000Z"
      },
      "regularPath": "/docs/theme-reco/api.html",
      "relativePath": "docs/theme-reco/api.md",
      "key": "v-5898f432",
      "path": "/docs/theme-reco/api.html"
    },
    {
      "title": "plugin",
      "frontmatter": {
        "title": "plugin",
        "date": "2020-05-28T00:00:00.000Z"
      },
      "regularPath": "/docs/theme-reco/plugin.html",
      "relativePath": "docs/theme-reco/plugin.md",
      "key": "v-4d610086",
      "path": "/docs/theme-reco/plugin.html"
    },
    {
      "title": "theme",
      "frontmatter": {
        "title": "theme",
        "date": "2020-05-27T00:00:00.000Z"
      },
      "regularPath": "/docs/theme-reco/theme.html",
      "relativePath": "docs/theme-reco/theme.md",
      "key": "v-18cf0bf2",
      "path": "/docs/theme-reco/theme.html"
    },
    {
      "frontmatter": {
        "layout": "Tags",
        "title": "Tags"
      },
      "regularPath": "/tag/",
      "key": "v-b1564aac",
      "path": "/tag/"
    },
    {
      "frontmatter": {
        "layout": "FrontmatterKey",
        "title": "Categories"
      },
      "regularPath": "/categories/",
      "key": "v-ef9325c4",
      "path": "/categories/"
    },
    {
      "frontmatter": {
        "layout": "TimeLines",
        "title": "Timeline"
      },
      "regularPath": "/timeline/",
      "key": "v-6319eb4e",
      "path": "/timeline/"
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "tag3 Tags"
      },
      "regularPath": "/tag/tag3/",
      "key": "v-1368f1e8",
      "path": "/tag/tag3/"
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "tag2 Tags"
      },
      "regularPath": "/tag/tag2/",
      "key": "v-1368f226",
      "path": "/tag/tag2/"
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "tag1 Tags"
      },
      "regularPath": "/tag/tag1/",
      "key": "v-1368f264",
      "path": "/tag/tag1/"
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "tag4 Tags"
      },
      "regularPath": "/tag/tag4/",
      "key": "v-1368f1aa",
      "path": "/tag/tag4/"
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "ESLint Tags"
      },
      "regularPath": "/tag/ESLint/",
      "key": "v-7c0b72d8",
      "path": "/tag/ESLint/"
    },
    {
      "frontmatter": {
        "layout": "Tag",
        "title": "ES6 Tags"
      },
      "regularPath": "/tag/ES6/",
      "key": "v-3257dcde",
      "path": "/tag/ES6/"
    },
    {
      "frontmatter": {
        "layout": "Category",
        "title": "category2 Categories"
      },
      "regularPath": "/categories/category2/",
      "key": "v-5ce69b59",
      "path": "/categories/category2/"
    },
    {
      "frontmatter": {
        "layout": "Category",
        "title": "category1 Categories"
      },
      "regularPath": "/categories/category1/",
      "key": "v-5ce69b3a",
      "path": "/categories/category1/"
    },
    {
      "frontmatter": {
        "layout": "Category",
        "title": "前端标准化 Categories"
      },
      "regularPath": "/categories/%E5%89%8D%E7%AB%AF%E6%A0%87%E5%87%86%E5%8C%96/",
      "key": "v-f6343622",
      "path": "/categories/前端标准化/"
    },
    {
      "frontmatter": {
        "layout": "Category",
        "title": "《ES6 教程》笔记 Categories"
      },
      "regularPath": "/categories/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/",
      "key": "v-b2aef3ee",
      "path": "/categories/《ES6 教程》笔记/"
    },
    {
      "frontmatter": {
        "layout": "Layout",
        "title": "Page 2 - ES6 | Tags"
      },
      "regularPath": "/tag/ES6/page/2/",
      "key": "v-1d4b4f0c",
      "path": "/tag/ES6/page/2/"
    },
    {
      "frontmatter": {
        "layout": "Layout",
        "title": "Page 3 - ES6 | Tags"
      },
      "regularPath": "/tag/ES6/page/3/",
      "key": "v-1d4b4f2b",
      "path": "/tag/ES6/page/3/"
    },
    {
      "frontmatter": {
        "layout": "Layout",
        "title": "Page 4 - ES6 | Tags"
      },
      "regularPath": "/tag/ES6/page/4/",
      "key": "v-1d4b4f4a",
      "path": "/tag/ES6/page/4/"
    },
    {
      "frontmatter": {
        "layout": "Layout",
        "title": "Page 2 - 《ES6 教程》笔记 | Categories"
      },
      "regularPath": "/categories/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/page/2/",
      "key": "v-60d96394",
      "path": "/categories/《ES6 教程》笔记/page/2/"
    },
    {
      "frontmatter": {
        "layout": "Layout",
        "title": "Page 3 - 《ES6 教程》笔记 | Categories"
      },
      "regularPath": "/categories/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/page/3/",
      "key": "v-60d963b3",
      "path": "/categories/《ES6 教程》笔记/page/3/"
    },
    {
      "frontmatter": {
        "layout": "Layout",
        "title": "Page 4 - 《ES6 教程》笔记 | Categories"
      },
      "regularPath": "/categories/%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/page/4/",
      "key": "v-60d963d2",
      "path": "/categories/《ES6 教程》笔记/page/4/"
    }
  ],
  "themeConfig": {
    "nav": [
      {
        "text": "Home",
        "link": "/",
        "icon": "reco-home"
      },
      {
        "text": "TimeLine",
        "link": "/timeline/",
        "icon": "reco-date"
      },
      {
        "text": "Docs",
        "icon": "reco-message",
        "items": [
          {
            "text": "vuepress-reco",
            "link": "/docs/theme-reco/"
          }
        ]
      },
      {
        "text": "Contact",
        "icon": "reco-message",
        "items": [
          {
            "text": "GitHub",
            "link": "https://github.com/recoluan",
            "icon": "reco-github"
          }
        ]
      }
    ],
    "sidebar": {
      "/docs/theme-reco/": [
        "",
        "theme",
        "plugin",
        "api"
      ]
    },
    "type": "blog",
    "blogConfig": {
      "category": {
        "location": 2,
        "text": "Category"
      },
      "tag": {
        "location": 3,
        "text": "Tag"
      }
    },
    "friendLink": [
      {
        "title": "午后南杂",
        "desc": "Enjoy when you can, and endure when you must.",
        "email": "1156743527@qq.com",
        "link": "https://www.recoluan.com"
      },
      {
        "title": "vuepress-theme-reco",
        "desc": "A simple and beautiful vuepress Blog & Doc theme.",
        "avatar": "https://vuepress-theme-reco.recoluan.com/icon_vuepress_reco.png",
        "link": "https://vuepress-theme-reco.recoluan.com"
      }
    ],
    "logo": "/logo.png",
    "search": true,
    "searchMaxSuggestions": 10,
    "lastUpdated": "Last Updated",
    "author": "YANG J.K",
    "authorAvatar": "/avatar.png",
    "record": "xxxx",
    "startYear": "2017"
  }
}